==============================================================================
l42/tools.lua
==============================================================================
   -- local dbg = require("debugger")
   -- dbg.auto_where = 2

 6 local api = vim.api

   local function p(value)
*0   echo(vim.inspect(value), true)
   end

   local function create_cmd(cmd_name, cmd_value, cmd_options, mapping)
*0   local cmd_options = cmd_options or {}
*0   api.nvim_create_user_command(cmd_name, cmd_value, cmd_options)

*0   if mapping then
*0     api.nvim_command('map ' .. mapping .. ' :' .. cmd_name .. '<CR>')
     end
   end

   local function echo(message, history, options)
*0   local history = history or false
*0   local options = options or {}
*0   api.nvim_echo({{message}}, history, options)
   end

   -- Exception Handling Ã  la Lua
   local function get_var(name)
     local getter = function()
*0     local val = vim.api.nvim_get_var(name)
*0     return val
     end
*0   local ok, val = pcall(getter)
*0   if ok then
*0     return val
     end
   end

   local function init_var(name, value)
*0   local old_value = get_var(name)
*0   if old_value then
*0     return old_value
     end

*0   api.nvim_set_var(name, value)
*0   return value
   end

 6 return {
 6   create_command = create_cmd,
 6   echo = echo,
 6   get_var = get_var,
 6   init_var = init_var,
 6   p = p
 6 }

==============================================================================
l42/tools/fn.lua
==============================================================================
   -- local dbg = require("debugger")
   -- dbg.auto_where = 2
 6 local append = require"l42.tools.list".append

 6 local function id(x) return x end

 6 local free = {}
   local function combine_params(dtp, ctp)
*0   local t = {}
*0   for _, value in ipairs(dtp) do
*0     if value == free then
*0       table.insert(t, table.remove(ctp, 1))
       else
*0       table.insert(t, value)
       end
     end
*0   return append(t, ctp)
   end

   local function merge_onto(target, src)
*0   for k, v in pairs(src) do
*0     target[k] = v
     end
   end

   local function merge(...)
*0   local result = {}
*0   local tables = {...}
*0   for _, table in ipairs(tables) do
*0     merge_onto(result, table)
     end
*0   return result
   end

   local function curry(fn, ...)
*0   local def_time_params = {...}
     return function(...)
*0     local call_time_params = {...}
*0     local total_params = append(def_time_params, call_time_params)
*0     return fn(table.unpack(total_params))
     end
   end

   local function curry_at(fn, ...)
*0   local def_time_params = {...}
     return function(...)
*0     local call_time_params = {...}
*0     local total_params = combine_params(def_time_params, call_time_params)
*0     return fn(table.unpack(total_params))
     end
   end

   local function curry_kwd(fn, ctkwds)
*0   local ctkwds = ctkwds
     return function(rtkwds)
*0     local total_kwds=merge(ctkwds, rtkwds)
*0     return fn(total_kwds)
     end
   end

   local function _access(container, idx)
*0   if type(container) == "string" then
*0     return string.sub(container, idx, idx)
     else
*0     return container[idx]
     end
   end

   local function foldl(list, fn, initial)
*0   local init_idx = 1
*0   local acc = initial
*0   if not acc then
*0     if #list == 0 then error("must not fold an empty list without an initial value") end
*0     init_idx = 2
*0     acc = list[1]
     end
*0   local size = #list
*0   for idx = init_idx, size do
*0     acc = fn(acc, _access(list, idx))
     end
*0   return acc
   end

   -- OMG for side effects
   local function each(list, fn)
*0   foldl(list, function(_, ele) fn(ele) end, true)
   end

   local function find(table, fn)
*0   for pattern, value in pairs(table) do
*0     if fn(pattern) then return value end
     end
*0   return nil
   end

   local function find_match(table, matchee)
*0   return find(table, function(pattern)
*0     return string.match(matchee, pattern)
     end)
   end

   local function _recursive_insert(list, values)
*0   if type(values) == "table" then
*0     for _, value in ipairs(values) do
*0       _recursive_insert(list, value)
       end
     else
*0     table.insert(list, values)
     end
   end
   local function flat_map(list, fn)
*0   local fn = fn or id
     local append = function(list, ele)
*0     _recursive_insert(list, fn(ele))
*0     return list
     end
*0   return foldl(list, append, {})
   end

   local function map(list, fn)
*0   local fn = fn or id
     local append = function(list, ele)
*0     table.insert(list, fn(ele))
*0     return list
     end
*0   return foldl(list, append, {})
   end
   local function range(low, high, step)
*0   local step = step or 1
*0   local result = {}
*0   for i = low, high, step do
*0     table.insert(result, i)
     end
*0   return result
   end

   local function reduce(table, initial, fn)
*0   for _, value in ipairs(table) do
*0     initial = fn(initial, value)
     end
*0   return initial
   end

 6 return {
 6   curry     = curry,
 6   curry_at  = curry_at,
 6   curry_kwd = curry_kwd,
 6   each      = each,
 6   find      = find,
 6   find_match = find_match,
 6   flat_map  = flat_map,
 6   foldl     = foldl,
 6   free      = free,
 6   id        = id,
 6   map       = map,
 6   merge     = merge,
 6   range     = range,
 6   reduce    = reduce
 6 }

==============================================================================
l42/tools/list.lua
==============================================================================
   -- local dbg = require("debugger")
   -- dbg.auto_where = 2
 6 local range = require'l42.tools.range'
   local slice

   local function append(list1, list2, fn)
*0   local result = {}
*0   if fn then
*0     for _, val in ipairs(list1) do
*0       table.insert(result, fn(val))
       end
*0     for _, val in ipairs(list2) do
*0       table.insert(result, fn(val))
       end
     else
*0     for _, val in ipairs(list1) do
*0       table.insert(result, val)
       end
*0     for _, val in ipairs(list2) do
*0       table.insert(result, val)
       end
     end
*0   return result
   end

   local function concat(...)
*0   local result = {}
*0   for _, table in ipairs({...}) do
*0     result = append(result, table)
     end
*0   return result
   end

   local function listmod(n, s)
*0   local r = n % s
*0   if r == 0 then
*0     return s
     else
*0     return r
     end
   end

   local function partition(list, spos, epos)
*0   local lhs = slice(list, 1, spos - 1)
*0   local mhs = slice(list, spos, epos)
*0   local rhs = slice(list, math.max(epos, spos - 1) + 1)

*0   return lhs, mhs, rhs
   end

   local function push(list, element, fn)
*0   local result = {}
     -- if fn then
     --   for _, val in ipairs(list1) do
     --     table.insert(result, fn(val))
     --   end
     --   table.insert(result, fn(element))
     -- else
*0     for _, val in ipairs(list) do
*0       table.insert(result, val)
       end
*0     table.insert(result, element)
     -- end
*0   return result
   end

   local function readonly(t, msg)
*0   local proxy = {}
*0   local mt = {
     __index = t,
     __newindex = function (t,k,v)
*0     error(msg or "attempt to update a read-only table", 2)
     end
     }
*0   setmetatable(proxy, mt)
*0   return proxy
   end

   local function _flatten(acc, list)
*0   for _, ele in ipairs(list) do
*0     if type(ele) == 'table' then
*0       _flatten(acc, ele)
       else
*0       table.insert(acc, ele)
       end
     end
*0   return acc
   end

   local function flatten(...)
*0   local list = {...}
*0   return _flatten({}, list)
   end
   slice = function(list, startpos, endpos, fn)
*0   local endpos = endpos or #list
*0   if endpos < 0 then
*0     endpos = #list + 1 + endpos
     end
*0   if startpos < 0 then
*0     startpos = #list + 1 + startpos
     end
*0   local rng = range(startpos, endpos):intersect(startpos, #list)
*0   local result = {}
*0   if fn then
*0     for idx in rng:iter() do
*0       table.insert(result, fn(list[idx]))
       end
     else
*0     for idx in rng:iter() do
*0       table.insert(result, list[idx])
       end
     end
*0   return result
   end

   local function rotate_left(list, by)
*0   local by = by or 1
*0   local t = {}
*0   local s = #list
*0   for idx, value in ipairs(list) do
*0     t[listmod(idx - by, s)] = value
     end
*0   return t
   end

   local function rotate_right(list, by)
*0   local by = by or 1
*0   local t = {}
*0   local s = #list
*0   for idx, value in ipairs(list) do
*0     t[listmod(idx + by, s)] = value
     end
*0   return t
   end

   local function replace(source, idx1, idx2, with)
*0   local lhs, middle, rhs = partition(source, idx1, idx2)
*0   local result = concat(lhs, with, rhs)
*0   return result
   end

   local function reverse(list)
*0   local result = {}
*0   for _, val in ipairs(list) do
*0     table.insert(result, 1, val)
     end
*0   return result
   end

   local function tail_from(list, fun, include)
*0   local include = include or false
*0   local result = {}
*0   for i = #list, 1, -1 do
*0     if fun(list[i]) then
*0       if include then
*0         table.insert(result, 1, list[i])
         end
*0       return result
       end
*0     table.insert(result, 1, list[i])
     end
*0   return result
   end
 6 return {
 6   append = append,
 6   concat = concat,
 6   flatten = flatten,
 6   partition = partition,
 6   push = push,
 6   readonly = readonly,
 6   replace = replace,
 6   reverse = reverse,
 6   rotate_left = rotate_left,
 6   rotate_right = rotate_right,
 6   slice  = slice,
 6   tail_from  = tail_from,
 6 }

==============================================================================
l42/tools/range.lua
==============================================================================
   -- local dbg = require("debugger")
   -- dbg.auto_where = 2

   local new

   local function _make_range(from, to)
*0   local t = {}
*0   for i = from, to do
*0     table.insert(t, i)
     end
*0   return t
   end

   local function _extract_limits(low_or_range, high_or_nil)
*0   if type(low_or_range) == "table" then
*0     return low_or_range.low, low_or_range.high
     else
*0     return low_or_range, (high_or_nil or low_or_range)
     end
   end

   local function _extend(self, lorrg, hornil)
*0   local low, high = _extract_limits(lorrg, hornil)
*0   local new_low = math.min(low, self.low)
*0   local new_high = math.max(high, self.high)
*0   return new(new_low, new_high)
   end

   local function _intersect(self, lorrg, hornil)
*0   local low, high = _extract_limits(lorrg, hornil)
*0   local new_low = math.max(low, self.low)
*0   local new_high = math.min(high, self.high)
*0   return new(new_low, new_high)
   end

   local function _iter(self)
*0   local count = self.low
*0   local high  = self.high
     return function()
*0     if count <= high then
*0       count = count + 1
*0       return count - 1
       end
     end
   end

   local function _to_list(self)
     -- dbg()
*0   if self._list then return self._list end 
*0   self._list = _make_range(self.low, self.high)
*0   return self._list
   end

   new = function(low, high)
*0   local high = high or low
*0   return {
       -- data
       low = low,
       high = high,
       _list = nil,
       -- methods
       extend = _extend,
       intersect = _intersect,
       iter = _iter,
       to_list = _to_list,
     }
   end
 6 return new

==============================================================================
l42/tools/string.lua
==============================================================================
   -- local dbg = require("debugger")
   -- dbg.auto_where = 2
 6 local map = require 'l42.tools.fn'.map
 6 local find_match = require 'l42.tools.fn'.find_match
   local _replacer

   local function chunk(str, spos, epos)
*0   local str   = str
*0   local startpos = spos or 1
*0   local endpos   = epos or #str
*0   return {
       chunk  = function() return string.sub(str, startpos, endpos) end,
       delete = function() return _replacer(str, startpos, endpos)("") end,
       endpos = function() return endpos end,
       prefix = function() return string.sub(str, 1, startpos - 1) end,
       replace = _replacer(str, startpos, endpos),
       startpos = function() return startpos end,
       string = function() return str end,
       suffix = function() return string.sub(str, endpos + 1, -1) end,
*0     to_s   = function(self) return {
*0       str = str, spos = startpos, epos = endpos, chunk = self.chunk() 
*0     } end
     }
   end

   _replacer = function(str, startpos, endpos)
     return function(new)
*0     local prefix = string.sub(str, 1, startpos - 1)
*0     local suffix = string.sub(str, endpos + 1, -1) 
*0     local newstr = prefix .. new .. suffix
*0     return chunk(newstr, startpos, startpos + #new - 1)
     end
   end

   local function match_at(str, pos, pattern)
*0   local pattern = pattern or "[%w_]+"
*0   local str     = str
*0   local pos     = pos
*0   local spos    = pos
*0   local epos    = pos - 1
     -- dbg()
     -- N.B. pfx and sfx overlap by one grapheme therefor the either both match or match not
*0   local pfx     = string.sub(str, 1, pos)
*0   local sfx     = string.sub(str, pos, -1)
*0   local pm      = string.match(pfx, pattern .. "$")
*0   local sm      = string.match(sfx, "^" .. pattern)
*0   if pm then
*0     return chunk(str, spos + 1 - #pm, epos + #sm)
     else
*0     return chunk(str, pos, pos - 1)
     end 
   end

   local function split(inputstr, sep)
*0   if sep == "" then
*0     return map(inputstr)
     end
*0   if sep == nil then
*0     sep = "%s"
     end
*0   local t={}
*0   for str in string.gmatch(inputstr, "([^"..sep.."]+)") do
*0     table.insert(t, str)
     end
*0   return t
   end


 6 local matching_pairs = {
 6   ["%w"] = "%W",
 6   ["%s"] = "%S"
   }

   local function find_matched(str, start, incr, pattern)
*0   local idx = start
*0   local len = #str
*0   while idx > 0 and idx <= len do
*0     if string.match(string.sub(str, idx, idx), pattern) then return idx end
*0     idx = idx + incr
     end
     -- print("idx "..idx)
*0   return idx
   end

   local function fst(input, size)
*0   local size = size or 1
*0   return string.sub(input, 1, size)
   end

   local function rst(input, from)
*0   local from = from or 1
*0   return string.sub(input, from + 1, string.len(input))
   end

   local function fst_and_rst(input, at)
*0   local at = at or 1
*0   return {fst(input, at), rst(input, at)}
   end

   local function rtrim(str, with)
*0   local with = with or "%s"
*0   local pattern = with .. "*$"
*0   return string.gsub(str, pattern, "")
   end

   local function split_at_col(line, col)
*0   local col = col + 1
*0   local char = string.sub(line, col, col)
*0   local matched = find_match(matching_pairs, char)
*0   if not matched then return "", line, "" end
*0   local lpos = find_matched(line, col-1, -1, matched)
*0   local rpos = find_matched(line, col+1, 1, matched)
     -- print("lpos"..lpos)
     -- print("rpos"..rpos)
*0   return string.sub(line, 1, lpos),
*0     string.sub(line, lpos+1, rpos-1),
*0     string.sub(line, rpos, #line)
   end

   local function strip(str)
*0   return string.gsub(string.gsub(str, "^%s*", ""), "%s*$", "")
   end

 6 return {
 6   chunk = chunk,
 6   match_at = match_at,
 6   fst_and_rst = fst_and_rst,
 6   rtrim = rtrim,
 6   split = split,
 6   split_at_col = split_at_col,
 6   strip = strip
 6 }

==============================================================================
Summary
==============================================================================

File                 Hits Missed Coverage
-----------------------------------------
l42/tools.lua        8    18     30.77%
l42/tools/fn.lua     19   63     23.17%
l42/tools/list.lua   15   81     15.62%
l42/tools/range.lua  1    25     3.85%
l42/tools/string.lua 14   56     20.00%
-----------------------------------------
Total                57   243    19.00%
